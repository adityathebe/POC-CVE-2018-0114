package main

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"flag"
	"fmt"
	"math/big"
	"os"
)

func writePubKeyToFile(publickey *rsa.PublicKey) {
	// dump public key to file
	publicKeyBytes, err := x509.MarshalPKIXPublicKey(publickey)
	if err != nil {
		fmt.Printf("error when dumping publickey: %s \n", err)
		os.Exit(1)
	}
	publicKeyBlock := &pem.Block{
		Type:  "PUBLIC KEY",
		Bytes: publicKeyBytes,
	}
	publicPem, err := os.Create("public.pem")
	if err != nil {
		fmt.Printf("error when create public.pem: %s \n", err)
		os.Exit(1)
	}
	err = pem.Encode(publicPem, publicKeyBlock)
	if err != nil {
		fmt.Printf("error when encode public pem: %s \n", err)
		os.Exit(1)
	}
}

func writePrivKeyToFile(privatekey *rsa.PrivateKey) {
	var privateKeyBytes []byte = x509.MarshalPKCS1PrivateKey(privatekey)
	privateKeyBlock := &pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: privateKeyBytes,
	}
	privatePem, err := os.Create("private.pem")
	if err != nil {
		fmt.Printf("error when create private.pem: %s \n", err)
		os.Exit(1)
	}
	err = pem.Encode(privatePem, privateKeyBlock)
	if err != nil {
		fmt.Printf("error when encode private pem: %s \n", err)
		os.Exit(1)
	}
}

func genRsaPrivKey() (*rsa.PrivateKey, *rsa.PublicKey) {
	privatekey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		fmt.Printf("Cannot generate RSA key\n")
		os.Exit(1)
	}

	return privatekey, &privatekey.PublicKey
}

// Jwk is the jwk
type Jwk struct {
	Kty string `json:"kty"`
	Kid string `json:"kid"`
	Use string `json:"use"`
	N   string `json:"n"`
	E   string `json:"e"`
}

// Header is the jwt header
type Header struct {
	Alg string `json:"alg"`
	Jwk Jwk    `json:"jwk"`
}

func getHeadersB64(n, e string) string {
	myJwk := Jwk{
		Kty: "RSA",
		Kid: "example@example.com",
		Use: "sig",
		N:   n,
		E:   e,
	}

	header := Header{
		Alg: "RS256",
		Jwk: myJwk,
	}

	headerBytes, err := json.Marshal(header)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return base64.RawURLEncoding.EncodeToString(headerBytes)
}

func main() {
	payload := flag.String("payload", "", "Payload as a string")
	flag.Parse()
	if *payload == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Encode Payload
	payloadB64 := base64.RawURLEncoding.EncodeToString([]byte(*payload))

	// Generate RSA key-pair
	privKey, pubKey := genRsaPrivKey()

	// Dump private key to file
	writePrivKeyToFile(privKey)
	writePubKeyToFile(pubKey)

	// Extract modulus
	nB64 := base64.RawURLEncoding.EncodeToString(pubKey.N.Bytes())

	// Extract exponent
	e := pubKey.E
	eBig := big.NewInt(int64(e))
	eB64 := base64.RawURLEncoding.EncodeToString(eBig.Bytes())

	// Hash header and payload
	headersB64 := getHeadersB64(nB64, eB64)
	data := headersB64 + "." + payloadB64
	hashed := sha256.Sum256([]byte(data))

	// Sign the hash
	sign, err := rsa.SignPKCS1v15(rand.Reader, privKey, crypto.SHA256, hashed[:])
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	signB64 := base64.RawURLEncoding.EncodeToString(sign)

	fmt.Println(data + "." + signB64)
}
