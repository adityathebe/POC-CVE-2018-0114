package main

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"flag"
	"fmt"
	"log"
	"math/big"
	"os"
)

// WritePubKeyToFile stores the RSA public key in PEM format as public.pem
func WritePubKeyToFile(publickey *rsa.PublicKey) error {
	publicKeyASNDER1, err := x509.MarshalPKIXPublicKey(publickey)
	if err != nil {
		return err
	}

	publicKeyBlock := &pem.Block{
		Type:  "PUBLIC KEY",
		Bytes: publicKeyASNDER1,
	}

	file, err := os.Create("public.pem")
	if err != nil {
		return nil
	}

	err = pem.Encode(file, publicKeyBlock)
	if err != nil {
		return nil
	}

	return nil
}

// WritePrivKeyToFile stores the RSA private key in PEM format as private.pem
func WritePrivKeyToFile(privatekey *rsa.PrivateKey) error {
	var privKeyASNDER []byte = x509.MarshalPKCS1PrivateKey(privatekey)
	privateKeyBlock := &pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: privKeyASNDER,
	}

	file, err := os.Create("private.pem")
	if err != nil {
		return err
	}

	if err := pem.Encode(file, privateKeyBlock); err != nil {
		return nil
	}

	return nil
}

// GenRsaPrivKey generates the RSA private key and returns it
// with the corresponding public key
func GenRsaPrivKey() (*rsa.PrivateKey, *rsa.PublicKey, error) {
	privatekey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, nil, err
	}

	return privatekey, &privatekey.PublicKey, nil
}

// Jwk is the jwk
type Jwk struct {
	Kty string `json:"kty"`
	Kid string `json:"kid"`
	Use string `json:"use"`
	N   string `json:"n"`
	E   string `json:"e"`
}

// Header is the jwt header
type Header struct {
	Alg string `json:"alg"`
	Jwk Jwk    `json:"jwk"`
}

func getHeadersB64(n, e string) string {
	myJwk := Jwk{
		Kty: "RSA",
		Kid: "example@example.com",
		Use: "sig",
		N:   n,
		E:   e,
	}

	header := Header{
		Alg: "RS256",
		Jwk: myJwk,
	}

	headerBytes, err := json.Marshal(header)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return base64.RawURLEncoding.EncodeToString(headerBytes)
}

func main() {
	payload := flag.String("payload", "", "Payload as a string")
	flag.Parse()
	if *payload == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Encode Payload
	payloadB64 := base64.RawURLEncoding.EncodeToString([]byte(*payload))

	// Generate RSA key-pair
	privKey, pubKey, err := GenRsaPrivKey()
	if err != nil {
		log.Fatal(err)
	}

	// Dump private key and public keys to file
	if err := WritePubKeyToFile(pubKey); err != nil {
		log.Fatal(err)
	}

	if err := WritePrivKeyToFile(privKey); err != nil {
		log.Fatal(err)
	}

	// Extract modulus
	nB64 := base64.RawURLEncoding.EncodeToString(pubKey.N.Bytes())

	// Extract exponent
	exp := big.NewInt(int64(pubKey.E))
	eB64 := base64.RawURLEncoding.EncodeToString(exp.Bytes())

	// Hash header and payload
	headersB64 := getHeadersB64(nB64, eB64)
	data := headersB64 + "." + payloadB64
	hash := sha256.Sum256([]byte(data))

	// Sign the hash
	sign, err := rsa.SignPKCS1v15(rand.Reader, privKey, crypto.SHA256, hash[:])
	if err != nil {
		log.Fatal(err)
	}
	signB64 := base64.RawURLEncoding.EncodeToString(sign)

	fmt.Println(data + "." + signB64)
}
